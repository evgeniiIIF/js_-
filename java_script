_____________________________________________________________Движки___________________________________________________________________________

У браузера есть собственный движок, который иногда называют «виртуальная машина JavaScript».

Разные движки имеют разные «кодовые имена». Например:

V8 – в Chrome и Opera.
SpiderMonkey – в Firefox.
…Ещё есть «Trident» и «Chakra» для разных версий IE, «ChakraCore» для Microsoft Edge, «Nitro» и «SquirrelFish» для Safari и т.д.
_____________________________________________________________Добавление скрипта___________________________________________________________________________

Вышеприведённый пример можно разделить на два скрипта:

<script src="file.js"></script>
<script>
  alert(1);
</script>
Итого
Для добавления кода JavaScript на страницу используется тег <script>
Атрибуты type и language необязательны.
Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>.
_____________________________________________________________Структура кода___________________________________________________________________________

alert("Теперь всё в порядке");

[1, 2].forEach(alert)
---------------------коментарии--------------------------
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
---------------------------------
/* Закомментировали код
alert('Привет');
*/
alert('Мир');
---------------------------------
Используйте горячие клавиши!
В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+/ для 
однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев
(выделите кусок кода и нажмите комбинацию клавиш).
В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.
_________________________________________________Строгий режим — "use strict"_____________________________________________________________________
"use strict";

// этот код работает в современном режиме
...
----------------
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке

"use strict";

// строгий режим не активирован
Над "use strict" могут быть записаны только комментарии.

-------------------
'use strict'; <Shift+Enter для перехода на новую строку>
//  ...ваш код...
<Enter для запуска>
В большинстве браузеров, включая Chrome и Firefox, это работает.

В старых браузерах консоль не учитывает такой use strict, там можно «оборачивать» код в функцию, вот так:

(function() {
  'use strict';

  // ...ваш код...
})()
_____________________________________________________________Переменные___________________________________________________________________________

Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!
-----------------
несколько переменных

let user = 'John';
let age = 25;
let message = 'Hello';
-------------------
Мы также можем изменить его столько раз, сколько захотим:

let message;

message = 'Hello!';

message = 'World!'; // значение изменено

alert(message);
-------------------
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!
------------------
Повторное объявление вызывает ошибку
Переменная может быть объявлена только один раз.

Повторное объявление той же переменной является ошибкой:

let message = "Это";

// повторение ключевого слова 'let' приводит к ошибке
let message = "Другое"; // SyntaxError: 'message' has already been declared
Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
-------------------
Имена переменных
В JavaScript есть два ограничения, касающиеся имён переменных:

Имя переменной должно содержать только буквы, цифры или символы $ и _.
Первый символ не должен быть цифрой.
Примеры допустимых имён:

let userName;
let test123;
Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое 
следующее слово начинается с заглавной буквы: myVeryLongName.

Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, 
как и буквы, без какого-либо особого значения.
Регистр имеет значение
Переменные с именами apple и AppLE – это две разные переменные.
--------------------
Зарезервированные имена
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

Например: let, class, return и function зарезервированы.

Приведённый ниже код даёт синтаксическую ошибку:

let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!
---------------------
Константы
Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

const myBirthday = '18.04.1982';
Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:

const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
Если программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через const.
--------------------
неизменяемые константы пишем в верхнем регистре
const COLOR_ORANGE = "#FF7F00";

изменяемые в нижнем
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
--------------------

_____________________________________________________________Типы данных___________________________________________________________________________

В JavaScript есть 8 основных типов.

number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
object для более сложных структур данных.
symbol для уникальных идентификаторов.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
_______________________________________Взаимодействие: alert, prompt, confirm__выпадаючие окна_______________________________________________________

Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

alert
показывает сообщение.
alert("Hello");
Hello
-------------
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null,
если была нажата кнопка «Отмена» или Esc с клавиатуры.Функция prompt принимает два аргумента:

result = prompt(title, [default]);
Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

title
Текст для отображения в окне.
default
Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.
Квадратные скобки в синтаксисе [...]
Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result. Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.

Например:

let age = prompt('Сколько тебе лет?', 100);

alert(`Тебе ${age} лет!`); // Тебе 100 лет!
Для IE: всегда устанавливайте значение по умолчанию
Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку "undefined" в поле для ввода.

Запустите код в Internet Explorer и посмотрите на результат:

let test = prompt("Test");
Чтобы prompt хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:

let test = prompt("Test", ''); // <-- для IE
------------------
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, 
если нажата кнопка «Отмена» или Esc с клавиатуры.
result = confirm(question);
Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

Результат – true, если нажата кнопка OK. В других случаях – false.

Например:

let isBoss = confirm("Ты здесь главный?");

alert( isBoss ); // true, если нажата OK
-----------------
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной 
частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия
с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

_____________________________________________________________Обьекты___________________________________________________________________________
let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};
_________________
если использовать число в качестве ключа, то оно превратится в строку "0":

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
_________________
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали
_________________

// получаем свойства объекта: получить значение свойства обьекта
alert( user.name ); // John
alert( user.age ); // 30
_________________
let key = prompt("Что вы хотите узнать о пользователе?", "name"); 
или let key = "name"

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name")
_________________

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
alert(user["likes birds"]); // true

Значение может быть любого типа. Давайте добавить свойство в обьект с логическим значением:
user.isAdmin = true;
user["likes birds"] = true;

удалить свойство обьекта 
delete user.age;

Проверить существует ли ключь в обьекте (свойство с ключем)
"age" in object
========или============
let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key

-----------------------
Цикл для обьектов «for…in»
Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
-----------------------
Проверка обьекта на пустоту
Просто в цикле перебираем свойства объекта и возвращаем false, как только встречаем свойство./
function isEmpty(obj) {
  for (let key in obj) {
    // если тело цикла начнет выполняться - значит в объекте есть свойства
    return false;
  }
  return true;
}
-----------------------
Упорядочевание свойств
свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
https://learn.javascript.ru/object#uporyadochenie-svoystv-obekta
-----------------------
Клонирование и объединение объектов, Object.assign
При копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект.
дублировать объект Создать независимую копию, клон?

Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех 
перечисленных объектов, начиная со второго, копируются в первый объект.
Возвращает объект dest.

et user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }
Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
___________________
Мы также можем использовать Object.assign для замены for..in на простое клонирование:

let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);
Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.
_____________
Глубокое клонирование, используя рекурсию.
Или, чтобы не изобретать велосипед, использовать готовую 
реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
-----------------------
Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который использовался для вызова метода.

Например:

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
-----------------------
Конструкторы, создание объектов через "new"
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // fals
_______________
ели есть return

function BigUser() {
  this.name = "Вася";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект

А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно)
function SmallUser() {
  this.name = "Вася";
  return; // <-- возвращает this
}
alert( new SmallUser().name );  // Вася
_______________
Создание методов в конструкторе
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
-----------------------
Символы
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

Если же мы действительно хотим вывести символ с помощью alert, 
то необходимо явно преобразовать его с помощью метода .toString(), вот так:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает
Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

let id = Symbol("id");
alert(id.description); // id
_______________________
Мы хотим добавить к ним идентификаторы.
Используем для этого символьный ключ:

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
_____________________
Символы в литеральном объекте
Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
___________
Символы игнорируются циклом for…in
А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
__________
Одинаковые символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
_____________
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
______________
Впрочем, для любых символов доступно свойство description.

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

alert( localSymbol.description ); // name
-----------------------
Преобразование объектов в примитивы
https://learn.javascript.ru/object-toprimitive

записать метод в обьект.
obj[Symbol.toPrimitive] = function(hint) {
  // должен вернуть примитивное значение
  // hint равно чему-то одному из: "string", "number" или "default"
};
______________
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
_____________
Методы toString и valueOf берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов.

Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти эти методы и вызвать их следующим образом:

toString -> valueOf для хинта со значением «string».
valueOf -> toString – в ином случае.
Для примера, используем их в реализации всё того же объекта user. Воспроизведём его поведение комбинацией методов toString и valueOf:

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
___________
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500

-----------------------
-----------------------
-----------------------
-----------------------









_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________


