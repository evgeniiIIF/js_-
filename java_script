_____________________________________________________________Движки___________________________________________________________________________

У браузера есть собственный движок, который иногда называют «виртуальная машина JavaScript».

Разные движки имеют разные «кодовые имена». Например:

V8 – в Chrome и Opera.
SpiderMonkey – в Firefox.
…Ещё есть «Trident» и «Chakra» для разных версий IE, «ChakraCore» для Microsoft Edge, «Nitro» и «SquirrelFish» для Safari и т.д.
_____________________________________________________________Добавление скрипта___________________________________________________________________________

Вышеприведённый пример можно разделить на два скрипта:

<script src="file.js"></script>
<script>
  alert(1);
</script>
Итого
Для добавления кода JavaScript на страницу используется тег <script>
Атрибуты type и language необязательны.
Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>.
_____________________________________________________________Структура кода___________________________________________________________________________

alert("Теперь всё в порядке");

[1, 2].forEach(alert)
---------------------коментарии--------------------------
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
---------------------------------
/* Закомментировали код
alert('Привет');
*/
alert('Мир');
---------------------------------
Используйте горячие клавиши!
В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+/ для 
однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев
(выделите кусок кода и нажмите комбинацию клавиш).
В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.
_________________________________________________Строгий режим — "use strict"_____________________________________________________________________
"use strict";

// этот код работает в современном режиме
...
----------------
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке

"use strict";

// строгий режим не активирован
Над "use strict" могут быть записаны только комментарии.

-------------------
'use strict'; <Shift+Enter для перехода на новую строку>
//  ...ваш код...
<Enter для запуска>
В большинстве браузеров, включая Chrome и Firefox, это работает.

В старых браузерах консоль не учитывает такой use strict, там можно «оборачивать» код в функцию, вот так:

(function() {
  'use strict';

  // ...ваш код...
})()
_____________________________________________________________Переменные___________________________________________________________________________

Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!
-----------------
несколько переменных

let user = 'John';
let age = 25;
let message = 'Hello';
-------------------
Мы также можем изменить его столько раз, сколько захотим:

let message;

message = 'Hello!';

message = 'World!'; // значение изменено

alert(message);
-------------------
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!
------------------
Повторное объявление вызывает ошибку
Переменная может быть объявлена только один раз.

Повторное объявление той же переменной является ошибкой:

let message = "Это";

// повторение ключевого слова 'let' приводит к ошибке
let message = "Другое"; // SyntaxError: 'message' has already been declared
Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
-------------------
Имена переменных
В JavaScript есть два ограничения, касающиеся имён переменных:

Имя переменной должно содержать только буквы, цифры или символы $ и _.
Первый символ не должен быть цифрой.
Примеры допустимых имён:

let userName;
let test123;
Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое 
следующее слово начинается с заглавной буквы: myVeryLongName.

Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, 
как и буквы, без какого-либо особого значения.
Регистр имеет значение
Переменные с именами apple и AppLE – это две разные переменные.
--------------------
Зарезервированные имена
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

Например: let, class, return и function зарезервированы.

Приведённый ниже код даёт синтаксическую ошибку:

let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!
---------------------
Константы
Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

const myBirthday = '18.04.1982';
Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:

const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
Если программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через const.
--------------------
неизменяемые константы пишем в верхнем регистре
const COLOR_ORANGE = "#FF7F00";

изменяемые в нижнем
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
--------------------

_____________________________________________________________Типы данных___________________________________________________________________________

В JavaScript есть 8 основных типов.

number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
object для более сложных структур данных.
symbol для уникальных идентификаторов.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
_______________________________________Взаимодействие: alert, prompt, confirm__выпадаючие окна_______________________________________________________

Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

alert
показывает сообщение.
alert("Hello");
Hello
-------------
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null,
если была нажата кнопка «Отмена» или Esc с клавиатуры.Функция prompt принимает два аргумента:

result = prompt(title, [default]);
Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

title
Текст для отображения в окне.
default
Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.
Квадратные скобки в синтаксисе [...]
Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result. Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.

Например:

let age = prompt('Сколько тебе лет?', 100);

alert(`Тебе ${age} лет!`); // Тебе 100 лет!
Для IE: всегда устанавливайте значение по умолчанию
Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку "undefined" в поле для ввода.

Запустите код в Internet Explorer и посмотрите на результат:

let test = prompt("Test");
Чтобы prompt хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:

let test = prompt("Test", ''); // <-- для IE
------------------
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, 
если нажата кнопка «Отмена» или Esc с клавиатуры.
result = confirm(question);
Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

Результат – true, если нажата кнопка OK. В других случаях – false.

Например:

let isBoss = confirm("Ты здесь главный?");

alert( isBoss ); // true, если нажата OK
-----------------
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной 
частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия
с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

_____________________________________________________________Обьекты___________________________________________________________________________
Объекты для хранения именованных коллекций.

let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};
_________________
если использовать число в качестве ключа, то оно превратится в строку "0":

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
_________________
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали
_________________

// получаем свойства объекта: получить значение свойства обьекта
alert( user.name ); // John
alert( user.age ); // 30
_________________
let key = prompt("Что вы хотите узнать о пользователе?", "name"); 
или let key = "name"

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name")
_________________

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
alert(user["likes birds"]); // true

Значение может быть любого типа. Давайте добавить свойство в обьект с логическим значением:
user.isAdmin = true;
user["likes birds"] = true;

удалить свойство обьекта 
delete user.age;

Проверить существует ли ключь в обьекте (свойство с ключем)
"age" in object
========или============
let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key

-----------------------
Цикл для обьектов «for…in»
Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
-----------------------
Проверка обьекта на пустоту
Просто в цикле перебираем свойства объекта и возвращаем false, как только встречаем свойство./
function isEmpty(obj) {
  for (let key in obj) {
    // если тело цикла начнет выполняться - значит в объекте есть свойства
    return false;
  }
  return true;
}
-----------------------
Упорядочевание свойств
свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
https://learn.javascript.ru/object#uporyadochenie-svoystv-obekta
-----------------------
Клонирование и объединение объектов, Object.assign
При копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект.
дублировать объект Создать независимую копию, клон?

Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех 
перечисленных объектов, начиная со второго, копируются в первый объект.
Возвращает объект dest.

et user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }
Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
___________________
Мы также можем использовать Object.assign для замены for..in на простое клонирование:

let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);
Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.
_____________
Глубокое клонирование, используя рекурсию.
Или, чтобы не изобретать велосипед, использовать готовую 
реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
-----------------------
Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который использовался для вызова метода.

Например:

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
-----------------------
Конструкторы, создание объектов через "new"
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // fals
_______________
ели есть return

function BigUser() {
  this.name = "Вася";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект

А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно)
function SmallUser() {
  this.name = "Вася";
  return; // <-- возвращает this
}
alert( new SmallUser().name );  // Вася
_______________
Создание методов в конструкторе
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
-----------------------
Символы
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

Если же мы действительно хотим вывести символ с помощью alert, 
то необходимо явно преобразовать его с помощью метода .toString(), вот так:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает
Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

let id = Symbol("id");
alert(id.description); // id
_______________________
Мы хотим добавить к ним идентификаторы.
Используем для этого символьный ключ:

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
_____________________
Символы в литеральном объекте
Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
___________
Символы игнорируются циклом for…in
А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
__________
Одинаковые символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
_____________
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
______________
Впрочем, для любых символов доступно свойство description.

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

alert( localSymbol.description ); // name
-----------------------
Преобразование объектов в примитивы
https://learn.javascript.ru/object-toprimitive

записать метод в обьект.
obj[Symbol.toPrimitive] = function(hint) {
  // должен вернуть примитивное значение
  // hint равно чему-то одному из: "string", "number" или "default"
};
______________
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
_____________
Методы toString и valueOf берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов.

Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти эти методы и вызвать их следующим образом:

toString -> valueOf для хинта со значением «string».
valueOf -> toString – в ином случае.
Для примера, используем их в реализации всё того же объекта user. Воспроизведём его поведение комбинацией методов toString и valueOf:

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
___________
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
_____________________________________________________________Числа___________________________________________________________________________
Чтобы писать числа с большим количеством нулей:

Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. Например: 123e-6 это 0.000123 (123 миллионных).
-----------------------
Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. 
Естественно, есть короткий стиль записи: 0x, после которого указывается число.

alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию parseInt
-----------------------
Число в строку
Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
-------
Две точки для вызова метода
Внимание! Две точки в 123456..toString(36) это не опечатка. 
Если нам надо вызвать метод непосредственно на числе, как toString в примере выше,
то нам надо поставить две точки .. после числа.
-----------------------
Округление

Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
-----------------------
Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:

let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(5).
-----------------------
isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN уникально тем,
что оно не является равным ни чему другому, даже самому себе:

alert( NaN === NaN ); // false
-----------------------
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

alert( isFinite("") ); // true
alert( isFinite(null) ); // true
alert( isFinite("15") ); // true

alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
Иногда isFinite используется для проверки, содержится ли в строке число
-----------------------
Сравнение Object.is
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. 
Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, 
он использует Object.is (Определение SameValue).
-----------------------
Число из строки с буквами. 
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
------------
Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, 
таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
-----------------------
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math
В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Несколько примеров:

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.

alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
Math.pow(n, power)
Возвращает число n, возведённое в степень power

alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024
В объекте Math есть множество функций и констант, включая тригонометрические функции, подробнее можно ознакомиться в документации по объекту Math.

_____________________________________________________________Строки___________________________________________________________________________

Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.
-----------------------
Длина строки
Свойство length содержит длину строки:

alert( `My\n`.length ); // 3
Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3.

length — это свойство
Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: они пишут str.length() вместо str.length. Это не работает.

Так как str.length — это числовое свойство, а не функция, добавлять скобки не нужно.
-----------------------
Доступ к символам
Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. 
Также можно использовать метод charAt: str.charAt(pos). Первый символ занимает нулевую позицию:

let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
-----------------------
Цикл для строк. for of - возвращает именно символ а не индекс как for in

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
}
-----------------------
Изменение регистра
Методы toLowerCase() и toUpperCase() меняют регистр символов:

alert( 'Interface'.toUpperCase() ); // INTERFACE - верхний регистр
alert( 'Interface'.toLowerCase() ); // interface - нижний регистр
Если мы захотим перевести в нижний регистр какой-то конкретный символ:

alert( 'Interface'[0].toLowerCase() ); // 'i'
-----------------------
Найти подстроку в строке. Найти позицию подстроки в строке.

str.indexOf
Первый метод — str.indexOf(substr, pos).

Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию,
на которой располагается совпадение, либо -1 при отсутствии совпадений.

let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
Необязательный второй аргумент позволяет начать поиск с определённой позиции.

Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:

let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
Тот же алгоритм можно записать и короче:

let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}

-----------строки------------
str.lastIndexOf(substr, position)
Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.
Он используется тогда, когда нужно получить самое последнее вхождение: 
перед концом строки или начинающееся до (включительно) определённой позиции.
-----------строки------------
Условие if для поиска подстроки в строке
Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, т. к. str.indexOf("Widget")
возвращает 0, и if решает, что тест не пройден.
Поэтому надо делать проверку на -1:

let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}
----------строки-------------
str.includes(substr, pos)

Проверить есть ли в строке подстрока. true / false
Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.
Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
----------строки-------------
Проверить начинается\кончается строка.
Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"
----------строки-------------
Получение подстроки. Получить подстроку
В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
substring(start, end)	между start и end	отрицательные значения равнозначны 0
substr(start, length)	length символов, начиная от start	значение start может быть отрицательным

str.slice(start [, end])
Возвращает часть строки от start до (не включая) end.

let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца
Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif
-----------строки------------
str.substring(start [, end])
Возвращает часть строки между start и end.

Это — почти то же, что и slice, но можно задавать start больше end.

Например:

let str = "stringify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)
Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

-----------строки------------
str.substr(start [, length])
Возвращает часть строки от start длины length.

В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );

-----------строки------------
Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. 
Есть специальные методы, позволяющие получить символ по его коду и наоборот.

str.codePointAt(pos)
Возвращает код для символа, находящегося на позиции pos:

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90

String.fromCodePoint(code)
Создаёт символ по его коду code

alert( String.fromCodePoint(90) ); // Z
Также можно добавлять юникодные символы по их кодам, используя \u с шестнадцатеричным кодом символа:

// 90 — 5a в шестнадцатеричной системе счисления
alert( '\u005a' ); // Z
Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
-----------------------
str.trim() — удаляет пробелы в начале и конце строки.
str.repeat(n) — повторить строку n раз.

_____________________________________________________________Массивы___________________________________________________________________________
Массивы для хранения упорядоченных коллекций.

---------Массивы--------------
Обьявление массива.
let arr = [];
----------Массивы-------------
Длина массива 
Общее число элементов массива содержится в его свойстве length:

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3
----------Массивы-------------
Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.
В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

pop
Удаляет последний элемент из массива и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удаляем "Груша" и выводим его
alert( fruits ); // Яблоко, Апельсин

push
Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша

shift
Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удаляем Яблоко и выводим его
alert( fruits ); // Апельсин, Груша

unshift
Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша

----------Массивы-------------
Цикл для массивов - for of
for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).

for (let i in arr) – никогда не используйте для массивов!
очистить массив – это arr.length = 0;
---------Массивы--------------
Многомерные массивы
Массивы могут содержать элементы, которые тоже являются массивами. 
Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, центральный элемент
----------Массивы-------------
toString 
https://learn.javascript.ru/array#tostring
Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
Давайте теперь попробуем следующее:

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".

Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:

alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"

----------Методы массивов-------------
arr.push(...items) – добавляет элементы в конец,
arr.pop() – извлекает элемент из конца,
arr.shift() – извлекает элемент из начала,
arr.unshift(...items) – добавляет элементы в начало.
-----------------------
Удалить эллементы из массива
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]

В следующем примере мы удалим 3 элемента и заменим их двумя другими.
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
----------
splice возвращает массив из удалённых элементов

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 2 первых элемента
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
-----------------------
Вставить эллементы в массив. Добавить в массив
let arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
-----------------------
Получить подмассив
arr.slice([start], [end])

let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

Копировать массив
slice и вообще без аргументов: arr.slice() создаёт копию массива arr
-----------------------
Собрать массив из нескольких массивов и значений
Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
arr.concat(arg1, arg2...)
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
------------concat для обьектов-----
Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  length: 1
};
alert( arr.concat(arrayLike) ); // 1,2,[object Object]

Но если объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается
concat как массив: вместо него добавляются его числовые свойства.

Для корректной обработки в объекте должны быть числовые свойства и length:

let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};
alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
-----------Методы массивов------------
Перебор: forEach
Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

Его синтаксис:
arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});

Например, этот код выведет на экран каждый элемент массива:
// Вызов alert для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

А этот вдобавок расскажет и о своей позиции в массиве:
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} имеет позицию ${index} в ${array}`);
});
Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
-----------Поиск в массиве------------
Поиск в массиве
arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.
Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является arr.includes.
Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf:

const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
-----------Поиск в массиве------------
find и findIndex
Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
Здесь пригодится метод arr.find.
Его синтаксис таков:

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
Функция вызывается по очереди для каждого элемента массива:

item – очередной элемент.
index – его индекс.
array – сам массив.
Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
--------------
Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Попробуем найти того, кто с id == 1:

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
let user = users.find(item => item.id == 1);
alert(user.name); // Вася

Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, 
а не сам элемент, и -1, если ничего не найдено.
-----------Поиск в массиве------------
filter возвращает массив из всех подходящих элементов.
let results = arr.filter(function(item, index, array) {
  // если true - элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2
------------
let arr = ['misha', 'vanya', 'petya', 'vasya', 'vartan']

let names = arr.filter(item => item.startsWith('va'))
//вернет["vanya", "vasya", "vartan"]
-----------Преобразование массива------------
map
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map

Метод arr.map является одним из наиболее полезных и часто используемых.
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
Синтаксис:
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
-----------Cортировка массива------------
sort(fn)
Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
Например:
let arr = [ 1, 2, 15 ];
// метод сортирует содержимое arr
arr.sort();
alert( arr );  // 1, 15, 2
По умолчанию элементы преобризуются и сортируются как строки.

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
Функция должна для пары значений возвращать:
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
  }
На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше»,
и отрицательное число, чтобы сказать «меньше».
Это позволяет писать более короткие функции:
let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; }); или arr.sort( (a, b) => a - b );
alert(arr);  // 1, 2, 15
-----------------------
Метод arr.reverse меняет порядок элементов в arr на обратный.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1
Он также возвращает массив arr с изменённым порядком элементов.
-----------------------
Массив из строки
let names = 'Вася, Петя, Маша';
let arr = names.split(', ');
for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.
Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
alert(arr); // Вася, Петя
--------
Разбивка по буквам
Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
let str = "тест";
alert( str.split('') ); // т,е,с,т
-----------------------
Строка из массива
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша
-----------------------
https://learn.javascript.ru/array-methods#reduce-reduceright
reduce/reduceRight
Если нам нужно перебрать массив – мы можем использовать forEach, for или for..of.
Если нам нужно перебрать массив и вернуть данные для каждого элемента – мы используем map.
Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. 
Они используются для вычисления какого-нибудь единого значения на основе всего массива.
Синтаксис:
let value = arr.reduce(function(previousValue, item, index, array) {// ...}, [initial]);
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.
Аргументы:
previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
item – очередной элемент массива,
index – его индекс,
array – сам массив.

Суммирование всех значений массива
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

Разворачивание массива массивов
var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {
  return a.concat(b);
});
// flattened равен [0, 1, 2, 3, 4, 5]
-----------------------
Проверить является ли массивом или нет
Array.isArray
Массивы не образуют отдельный тип языка. Они основаны на объектах.

Поэтому typeof не может отличить простой объект от массива:

alert(typeof {}); // object
alert(typeof []); // тоже object
…Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). Он возвращает true, если value массив, и false, если нет.

alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
-----------------------
Большинство методов поддерживают «thisArg»
Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort,
принимают необязательный параметр thisArg.

Вот полный синтаксис этих методов:
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент
Значение параметра thisArg становится this для func.

Например, вот тут мы используем метод объекта army как фильтр, и thisArg передаёт ему контекст:

let army = {
  minAge: 1,
  maxAge: 5,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let obj = {
  minAge: 5, 
  maxAge: 10
};

let users = [
  {age: 1},
  {age: 3},
  {age: 6},
  {age: 7}
];

// найти пользователей, для которых army.canJoin возвращает true

let soldiers = users.filter(army.canJoin, obj);
// console.log(soldiers.length); // 2
console.log(soldiers[0].age); // 6
console.log(soldiers[1].age); // 7

или обращаемся к другому обьекту для получения других значений this
let soldiers = users.filter(army.canJoin, army);
// console.log(soldiers.length); // 2
console.log(soldiers[0].age); // 1
console.log(soldiers[1].age); // 3
_____________________________________________________________Перебираемые объекты___________________________________________________________________________
https://learn.javascript.ru/iterable#array-from
Symbol.iterator

let range = {
  from: 1,
  to: 5,
  [Symbol.iterator]: function(){
    return  {
      current: this.from,
      last: this.to,
      
      next() {
        if (this.current <= this.last) {
          return {done: false, value: this.current++};
        }else {
          return {done: true};
        }
      }
    }
  }
};

// for(key of range) {
//   console.log(key);
// }


let a = range[Symbol.iterator]();

console.log(a.next());
-----------------------
Итератор строк

let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}
-----------------------
Итерируемые объекты и псевдомассивы
Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.
Array.from - Перевести в массив______.

let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
--------------------------
// range взят из примера выше
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (преобразование массива через toString работает)
---------------------------
Из обьекта в псевдомассив

let obj = {
  name: 'Jon',
  surname: 'Smith',
  age: 22
};

let obj2 = Object.fromEntries(Object.values(obj).map((item, index) => [index, item]) )
obj.length = Object.keys(obj).length
console.log(obj2)

_____________________________________________________________Map___________________________________________________________________________
Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные 
коллекции,но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

Map
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Методы и свойства:

new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.
--------------
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3
--------------
Map может использовать объекты в качестве ключей.

let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123
--------------
Цепочка вызовов
Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:

map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
--------------
Перебор Map.  Цикл для Map for of
Для перебора коллекции Map есть 3 метода:

map.keys() – возвращает итерируемый объект по ключам,
map.values() – возвращает итерируемый объект по значениям,
map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
Например:

let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
  alert(entry); // огурец,500 (и так далее)
}
--------------
Используется порядок вставки
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.

Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});
--------------
Создать заполненный Map.
При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:

// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
-------
Object.entries: Map из Object ----- Map из обьекта.  Из обьекта в Map

Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет
встроенный метод Object.entries(obj), который получает объект и возвращает массив пар 
ключ-значение для него, как раз в этом формате.
Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

Здесь Object.entries возвращает массив пар ключ-значение: [ ["name","John"], ["age", 30] ].
Это именно то, что нужно для создания Map.
--------------
Object.fromEntries: Object из Map ----- Из Map в обьект.

Метод Object.fromEntries, получив массив пар вида [ключ, значение], создаёт из них объект:

let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
--------------
Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

К примеру, у нас данные в Map, но их нужно передать в сторонний код, который ожидает обычный объект.
Вот как это сделать:

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
Вызов map.entries() возвращает массив пар ключ/значение, как раз в нужном формате для Object.fromEntries.
Мы могли бы написать строку (*) ещё короче:

let obj = Object.fromEntries(map); // убрать .entries()
Это то же самое, так как Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив.
А перебор map как раз возвращает пары ключ/значение, так же, как и map.entries(). Так что в итоге у нас будет обычный
объект с теми же ключами/значениями, что и в map.
_____________________________________________________________Set___________________________________________________________________________
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен 
итерируемый объект (обычно это массив), то копирует его значения в новый Set.
set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.

Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением
ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.
--------------
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}
--------------
Перебор объекта Set
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:

let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом сновато же самое 
значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. Выглядит немного странно,
но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

Set имеет те же встроенные методы, что и Map:

set.values() – возвращает перебираемый объект для значений,
set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.
--------------------------------------Перевод из одной структуры в другую---------------------------------
Obj to Arr
let obj = {
  name: "jon",
  subname: "Smit",
  age: 18,
};

let arr = Object.keys(obj); // ["name", "subname", "age"]
let arr = Object.values(obj); // ["jon", "Smit", 18]
let arr = Object.entries(obj); // [["name", "jon"], ["subname", "Smit"], ["age", 18]]
--------------
Obj to Map
let map = new Map(Object.entries(obj));//Array.from(map) // [["name", "jon"], ["subname", "Smit"], ["age", 18]]
--------------
Map to Obj
let obj = Object.fromEntries(map.entries());
--------------
Map to Arr
Array.from( map.values() )// ["jon", "Smit", 18]
Array.from( map.keys() )// ["name", "subname", "age"]
Array.from( map.entries() )// [["name", "jon"], ["subname", "Smit"], ["age", 18]]
-------------
Arr to Obj
let arr = [["name", "jon"], ["subname", "Smit"], ["age", 18]]
obj2 = Object.fromEntries(arr) // {age: 18, name: "jon", subname: "Smit"};
-------------
Arr to Map
let map2 = new Map(arr) // arr должен иметь вид [["name", "jon"], ["subname", "Smit"], ["age", 18]];
----
let map2 = new Map( arr.entries() );//[[0, ["name", "jon"]], [1, ["subname", "Smit"]], [2, ["age", 18]]]
_____________________________________________________________WeakMap___________________________________________________________________________

WeakMap
Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект
Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

let john = { name: "John" };
let weakMap = new WeakMap();
weakMap.set(john, "...");
john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!
------------
В WeakMap присутствуют только следующие методы:

weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)
----------------
Предположим, у нас есть код, который ведёт учёт посещений для пользователей. 
Информация хранится в коллекции WeakMap: объект, представляющий пользователя, 
является ключом, а количество визитов – значением. Когда пользователь нас покидает 
(его объект удаляется сборщиком мусора),то больше нет смысла хранить соответствующий счётчик посещений.

// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}

А вот другая часть кода, возможно, в другом файле, которая использует countUser:

// 📁 main.js
let john = { name: "John" };

countUser(john); //ведём подсчёт посещений
console.log(visitsCountMap.get(jon))

// пользователь покинул нас
john = null;
Теперь объект john должен быть удалён сборщиком мусора
----------------
Применение для кеширования
Другая частая сфера применения – это кеширование, когда результат вызова функции
должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы 
на том же объекте могли просто брать уже готовый результат,
повторно используя его.

let cache = new WeakMap();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* какой-то объект */};

let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен:
obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются

_____________________________________________________________WeakSet___________________________________________________________________________
Коллекция WeakSet ведёт себя похоже:

Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища.
Но не для произвольных данных, а скорее для значений типа «да/нет». 
Присутствие во множестве WeakSet может что-то сказать нам об объекте.

Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:

let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически

Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое.
Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять 
их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.



______________________________________________Object.keys, values, entries_____________________________________________________
Для простых объектов доступны следующие методы:

Object.keys(obj) – возвращает массив ключей.
Object.values(obj) – возвращает массив значений.
Object.entries(obj) – возвращает массив пар [ключ, значение].
-----------
Object.keys/values/entries игнорируют символьные свойства
Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.

Обычно это удобно. Но если требуется учитывать и символьные ключи, то для этого существует отдельный метод 
Object.getOwnPropertySymbols,возвращающий массив только символьных ключей. Также, существует метод
Reflect.ownKeys(obj), который возвращает все ключи.
--------------
Трансформации объекта
У объектов нет множества методов, которые есть в массивах, например map, filter и других.

Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:

Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
На нём вызываем методы массива, например, map.
Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
Например, у нас есть объект с ценами, и мы хотели бы их удвоить:

let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
Это может выглядеть сложным на первый взгляд, 
но становится лёгким для понимания после нескольких раз использования.

Можно делать и более сложные «однострочные» преобразования таким путём. Важно только сохранять баланс, 
чтобы код при этом был достаточно простым для понимания.


_____________________________________________________Деструктурирующее присваивание_____________________________________________
Деструктуризация массива
Пример деструктуризации массива:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
Теперь мы можем использовать переменные вместо элементов массива.

Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');
------------------------
Пропускайте элементы, используя запятые
Ненужные элементы массива также могут быть отброшены через запятую:

// второй элемент не нужен
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
В примере выше второй элемент массива пропускается, а третий присваивается переменной title, 
оставшиеся элементы массива также пропускаются (так как для них нет переменных).
---------------------
Работает с любым перебираемым объектом с правой стороны
…На самом деле мы можем использовать любой перебираемый объект, не только массивы:

let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);
Присваивайте чему угодно с левой стороны
Мы можем использовать что угодно «присваивающее» с левой стороны.

Например, можно присвоить свойству объекта:

let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
----------------------
Цикл с .entries()
В предыдущей главе мы видели метод Object.entries(obj).

Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:

let user = {
  name: "John",
  age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
…то же самое для map:

let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
---------------------
Остаточные параметры «…»
Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// Обратите внимание, что `rest` является массивом.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
---------------
Значения по умолчанию
Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:

let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
Если нам необходимо указать значения по умолчанию, то мы можем использовать =:

// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // Anonymous (значение по умолчанию)
Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

Например, здесь мы используем функцию prompt для указания двух значений по умолчанию. Но она будет запущена только для отсутствующего значения:

// prompt запустится только для surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // результат prompt
------------------
Деструктуризация объекта
Деструктурирующее присваивание также работает с объектами.

Синтаксис:

let {var1, var2} = {var1:…, var2:…}
У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}.

Например:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения. Вот так – тоже работает:

// изменён порядок в let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.

Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height сохраняется в h, а title присваивается одноимённой переменной.

Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь:

let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.

В коде ниже prompt запросит width, но не title:

let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (результат prompt)
Мы также можем совмещать : и =:

let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// взять только title, игнорировать остальное
let { title } = options;

alert(title); // Menu
------------------------
Вложенная деструктуризация
Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более
сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.

В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items. 
Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:

let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
Весь объект options, кроме свойства extra, которое в левой части отсутствует, присваивается в соответствующие переменные:
В итоге у нас есть width, height, item1, item2 и title со значением по умолчанию.
Заметим, что переменные для size и items отсутствуют, так как мы взяли сразу их содержимое.
-----------------
Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...и она немедленно извлекает свойства в переменные

function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
--------------------------
Мы также можем использовать более сложное деструктурирование с вложенными объектами и двоеточием:

let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width присваиваем в w
  height: h = 200, // height присваиваем в h
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
--------------------
Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() 
будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:

showMenu({}); // ок, все значения - по умолчанию

showMenu(); // так была бы ошибка
Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров:

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.

_____________________________________________________________Дата и Время___________________________________________________________________________
let now = new Date();
alert( now ); // показывает текущие дату и времяlet now = new Date();
alert( now ); // показывает текущие дату и время
---------------------
new Date(milliseconds)
Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

Это – легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью new Date(timestamp) и 
преобразовать существующий объект Date в таймстамп, используя метод date.getTime() (см. ниже).
---------------------
new Date(datestring)
Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же,
как в Date.parse, который мы рассмотрим позже.

let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)
---------------------
new Date(year, month, date, hours, minutes, seconds, ms)
Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.

year должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет.
month начинается с 0 (январь) по 11 (декабрь).
Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.
Например:

new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
Максимальная точность – 1 мс (до 1/1000 секунды):

let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
---------------------
Получение компонентов даты
Существуют методы получения года, месяца и т.д. из объекта Date:

getFullYear() - Получить год (4 цифры)
getMonth() - Получить месяц, от 0 до 11.
getDate() - Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
getDay() - Вернуть день недели от 0 (воскресенье) до 6 (суббота).
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Получить, соответственно, часы, минуты, секунды или миллисекунды.
---------------------
Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.
Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: 
getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".

Если ваш местный часовой пояс смещён относительно UTC, то следующий код покажет разные часы:

// текущая дата
let date = new Date();

// час в вашем текущем часовом поясе
alert( date.getHours() );

// час в часовом поясе UTC+0 (лондонское время без перехода на летнее время)
alert( date.getUTCHours() );
---------------------
Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

getTime()
Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

getTimezoneOffset()
Возвращает разницу в минутах между местным часовым поясом и UTC:

// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
alert( new Date().getTimezoneOffset() );
---------------------
Установка компонентов даты
https://learn.javascript.ru/date#ustanovka-komponentov-daty
Следующие методы позволяют установить компоненты даты и времени:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: 
setHours. Если какая-то компонента не указана, она не меняется.

let today = new Date();

today.setHours(0);
alert(today); // выводится сегодняшняя дата, но значение часа будет 0

today.setHours(0, 0, 0, 0);
alert(today); // всё ещё выводится сегодняшняя дата, но время будет ровно 00:00:00.
---------------------
Автоисправление даты
let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // задать первое число месяца
alert( date );

date.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца
alert( date ); // 31 Dec 2015
---------------------
Date.now()
Если нужно просто измерить время, объект Date нам не нужен.
Существует особый метод Date.now(), возвращающий текущую метку времени.
Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. 
Так что этот способ работает быстрее и не нагружает сборщик мусора.
Данный метод используется из соображений удобства или когда важно быстродействие, например, 
при разработке игр на JavaScript или других специализированных приложений.

let start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // заканчиваем отсчёт времени

alert( `Цикл отработал за ${end - start} миллисекунд` ); // вычитаются числа, а не даты
---------------------
Бенчмаркинг
https://learn.javascript.ru/date#benchmarking

function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// bench(upperSlice) и bench(upperLoop) поочерёдно запускаются 10 раз
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Итоговое время diffSubtract: ' + time1 );
alert( 'Итоговое время diffGetTime: ' + time2 );
---------------------
Разбор строки с датой
Метод Date.parse(str) считывает дату из строки.

Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:

YYYY-MM-DD – это дата: год-месяц-день.
Символ "T" используется в качестве разделителя.
HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.
Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается NaN.

Например:

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)
Можно тут же создать объект new Date из таймстампа:

let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);

__________________________________________________Формат JSON, метод toJSON_______________________________________________________
JSON.stringify для преобразования объектов в JSON.
JSON.parse для преобразования JSON обратно в объект.

------JSON.stringify------

let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* вся структура преобразована в строку:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
----------
JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify
пропускает некоторые специфические свойства объектов JavaScript.

А именно:

Свойства-функции (методы).
Символьные свойства.
Свойства, содержащие undefined.
let user = {
  sayHi() { // будет пропущено
    alert("Hello");
  },
  [Symbol("id")]: 123, // также будет пропущено
  something: undefined // как и это - пропущено
};

alert( JSON.stringify(user) ); // {} (пустой объект)
---------------
Важное ограничение: не должно быть циклических ссылок.

Например:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup ссылается на room
room.occupiedBy = meetup; // room ссылается на meetup

JSON.stringify(meetup); // Ошибка: Преобразование цикличной структуры в JSON
Здесь преобразование завершается неудачно из-за циклической ссылки: room.occupiedBy ссылается на meetup, 
и meetup.place ссылается на room:
---->
Исключаем и преобразуем: replacer
Полный синтаксис JSON.stringify:

let json = JSON.stringify(value[, replacer, space])
value
Значение для кодирования.
replacer
Массив свойств для кодирования или функция соответствия function(key, value).
space
Дополнительное пространство (отступы), используемое для форматирования.

Давайте включим в список все свойства, кроме room.occupiedBy, из-за которого появляется цикличная ссылка:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
------>
Теперь всё, кроме occupiedBy, сериализовано. Но список свойств довольно длинный.

К счастью, в качестве replacer мы можем использовать функцию, а не массив.

Функция будет вызываться для каждой пары (key, value), и она должна возвращать заменённое значение, 
которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.

В нашем случае мы можем вернуть value «как есть» для всего, кроме occupiedBy. Чтобы игнорировать occupiedBy,
код ниже возвращает undefined:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* пары ключ:значение, которые приходят в replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
Обратите внимание, что функция replacer получает каждую пару ключ/значение, включая вложенные объекты и элементы массива.
И она применяется рекурсивно. Значение this внутри replacer – это объект, который содержит текущее свойство.

Первый вызов – особенный. Ему передаётся специальный «объект-обёртка»: {"": meetup}. Другими словами, первая (key, value) 
пара имеет пустой ключ, а значением является целевой объект в общем.
Вот почему первая строка из примера выше будет ":[object Object]".

Идея состоит в том, чтобы дать как можно больше возможностей replacer – у него есть возможность 
проанализировать и заменить/пропустить даже весь объект целиком, если это необходимо.
---------------
Форматирование: space
Третий аргумент в JSON.stringify(value, replacer, space) – это количество пробелов,
используемых для удобного форматирования.

Ранее все JSON-форматированные объекты не имели отступов и лишних пробелов. 
Это нормально, если мы хотим отправить объект по сети. Аргумент space 
используется исключительно для вывода в удобочитаемом виде.

Ниже space = 2 указывает JavaScript отображать вложенные объекты 
в несколько строк с отступом в 2 пробела внутри объекта:

let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* отступ в 2 пробела:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* для JSON.stringify(user, null, 4) результат содержит больше отступов:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
Параметр space применяется для логирования и красивого вывода.
---------------
Пользовательский «toJSON»
Как и toString для преобразования строк, объект может предоставлять метод toJSON 
для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.

Например:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
Как видим, date (1) стал строкой. Это потому, что все объекты типа Date имеют
встроенный метод toJSON, который возвращает такую строку.

Теперь давайте добавим собственную реализацию метода toJSON в наш объект room (2):

let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
Как видите, toJSON используется как при прямом вызове JSON.stringify(room),
так и когда room вложен в другой сериализуемый объект.
---------------
JSON.parse
Чтобы декодировать JSON-строку, нам нужен другой метод с именем JSON.parse.

Синтаксис:

let value = JSON.parse(str, [reviver]);
str
JSON для преобразования в объект.
reviver
Необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение.
Например:

// строковый массив
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
Или для вложенных объектов:

let user = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

user = JSON.parse(user);

alert( user.friends[1] ); // 1
------>
Использование reviver
Давайте передадим JSON.parse функцию восстановления вторым аргументом, которая возвращает все значения «как есть», но date станет Date:

let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // 30 - теперь работает!
Кстати, это работает и для вложенных объектов:

let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // 18 - отлично!

______________________________________________________Рекурсия и стек________________________________________________

https://learn.javascript.ru/recursion#vyvod-odnosvyaznogo-spiska-v-obratnom-poryadke

Фебоначи

function feb(n) {
  let a = 1, b = 1, c;
  
  for (let i = 3; i <= n; i++) {
    c = a + b;
    
    a = b;
    b = c;
    
  }
  return b;
}

console.log(feb(7))

_____________________________________Остаточные параметры и оператор расширения_______________________________________
Остаточные параметры (...)
Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.

Например:

function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.

Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся 
параметры и положи их в массив».
---------------
Мы можем положить первые несколько параметров в переменные, а остальные – собрать в массив.

В примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие превратятся в массив titles:

function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Юлий Цезарь

  // Оставшиеся параметры пойдут в массив
  // titles = ["Консул", "Император"]
  alert( titles[0] ); // Консул
  alert( titles[1] ); // Император
  alert( titles.length ); // 2
}

showName("Юлий", "Цезарь", "Консул", "Император");
---------------
Остаточные параметры должны располагаться в конце
Остаточные параметры собирают все остальные аргументы, поэтому бессмысленно писать что-либо после них. Это вызовет ошибку:

function f(arg1, ...rest, arg2) { // arg2 после ...rest ?!
  // Ошибка
}
...rest должен всегда быть последним.
------------------
Стрелочные функции не имеют "arguments" (и this);
Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.
-----------------
Оператор расширения
Мы узнали, как получить массив из списка параметров.

Но иногда нужно сделать в точности противоположное.

Например, есть встроенная функция Math.max. Она возвращает наибольшее число из списка:

Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.

Для Math.max:

let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
Этим же способом мы можем передать несколько итерируемых объектов:

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
Мы даже можем комбинировать оператор расширения с обычными значениями:

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
Оператор расширения можно использовать и для слияния массивов:

let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, 
но он работает с любым перебираемым объектом.

----------------------

Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:

let str = "Привет";

alert( [...str] ); // П,р,и,в,е,т
Посмотрим, что происходит. Под капотом оператор расширения использует итераторы, 
чтобы перебирать элементы. Так же, как это делает for..of.

Цикл for..of перебирает строку как последовательность символов, поэтому из ...str 
получается "П", "р", "и", "в", "е", "т". Получившиеся символы собираются в массив при помощи 
стандартного объявления массива: [...str].

Для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив:

let str = "Привет";

// Array.from преобразует перебираемый объект в массив
alert( Array.from(str) ); // П,р,и,в,е,т
Результат аналогичен [...str].

Но между Array.from(obj) и [...obj] есть разница:

Array.from работает как с псевдомассивами, так и с итерируемыми объектами
Оператор расширения работает только с итерируемыми объектами
Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.
----------------
Итого
Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.

Как отличить их друг от друга:

Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
Полезно запомнить:

Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.

К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.

_______________________________________________________Замыкание_____________________________________________________________
https://learn.javascript.ru/closure

Один вызов – одно лексическое окружение
Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, 
специфичными для этого вызова, локальными переменными и параметрами.
-------------
Замыкания
В программировании есть общий термин: «замыкание», – которое должен знать каждый разработчик.

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание.
Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями 
(есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они
могут получить доступ к внешним переменным.

Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным
ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются
замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, 
как работает лексическое окружение.
-------------
Блоки кода и циклы, IIFE
https://learn.javascript.ru/closure#bloki-koda-i-tsikly-iife

________________________________________________Устаревшее ключевое слово "var"________________________________________________
Для «var» не существует блочной области видимости
Область видимости переменных var ограничивается либо функцией,
либо, если переменная глобальная, то скриптом. Такие переменные доступны за пределами блока.

Переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того,
в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).

Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения 
всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:

function sayHi() {
  var phrase; // объявление переменной срабатывает вначале...

  alert(phrase); // undefined

  phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
}

sayHi();

Поскольку все объявления переменных var обрабатываются в начале функции, мы можем ссылаться на них в любом месте. 
Однако, переменные имеют значение undefined до строки с присвоением значения.

В обоих примерах выше вызов alert происходил без ошибки, потому что переменная phrase уже существовала. 
Но её значение ещё не было присвоено, поэтому мы получали undefined.

__________________________________________________________Глобальный объект_________________________________________________________
https://learn.javascript.ru/global-object
Итого
Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, 
window.innerHeight – высота окна браузера.

Глобальный объект имеет универсальное имя – globalThis.

…Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window 
(браузер) и global (Node.js). Так как globalThis появился недавно, он не поддерживается в IE и Edge (не-Chromium версия),
но можно использовать полифил.

Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться
свести их количество к минимуму.

В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся 
свойствами глобального объекта.

Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта 
напрямую, как window.x.
______________________________________________________Объект функции, NFE_________________________________________________
Итого
Функции – это объекты.

Их свойства:

name – имя функции. Обычно берётся из объявления функции, но если там нет – JavaScript пытается понять его из контекста.
length – количество аргументов в объявлении функции. Троеточие («остаточные параметры») не считается.
Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя, тогда это называется 
Named Function Expression (Именованным Функциональным Выражением). Это имя может быть использовано для ссылки на себя же,
для рекурсивных вызовов и т.п.

Также функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.

Они создают «основную» функцию и добавляют множество «вспомогательных» функций внутрь первой. Например, библиотека 
jQuery создаёт функцию с именем $. Библиотека lodash создаёт функцию _, а потом добавляет в неё _.clone, _.keyBy и 
другие свойства (чтобы узнать о ней побольше см. документацию). Они делают это, чтобы уменьшить засорение глобального 
пространства имён посредством того, что одна библиотека предоставляет только одну глобальную переменную, 
уменьшая вероятность конфликта имён.

Таким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезную функциональность 
через свои свойства.

__________________________________________Синтаксис "new Function"___________________________________________________

function print() {
  let value = "vooou";
  return new Function("console.log(value)");  
}

window.value = "holla";

print()() // "holla"
-------
Итого
Синтаксис:

let func = new Function ([arg1, arg2, ...argN], functionBody);
По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.

Эти 3 объявления ниже эквивалентны:

new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке

Функции, объявленные через new Function, имеют [[Environment]], ссылающийся на глобальное лексическое окружение,
а не на родительское. Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому 
что страхует нас от ошибок. Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает 
проблем у минификаторов.
____________________________________________Планирование: setTimeout и setInterval_____________________________________________
https://learn.javascript.ru/settimeout-setinterval

setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
------------
let tick = setInterval( (a) => console.log(a), 1000, "a + b");
setTimeout( () => { clearInterval(tick); console.log("stop"); }, 5000 )

Пять раз выполнится "a + b" затем остановится;
-----------
рекурсивный setTimeout:

let i = 1;
setTimeout(function run() {
  func(i);
  setTimeout(run, 100);
}, 100);

Рекурсивныйse
tTimeout гарантирует фиксированную задержку
-----------
setTimeout с нулевой задержкой
этот код выводит «Привет» и затем сразу «Мир»:

setTimeout(() => alert("Мир"));
alert("Привет");

Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь» только 
после того, как текущий код завершится.Поэтому "Привет" выводится первым, а "Мир" – после него.
----------
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // запоминаем задержку от предыдущего вызова

  if (start + 100 < Date.now()) alert(times); // показываем задержку через 100 мс
  else setTimeout(run); // если нужно ещё запланировать
});

// пример вывода:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100

Первый таймер запускается сразу (как и указано в спецификации), а затем задержка вступает в игру, и мы видим 9, 15, 20, 24....
Аналогичное происходит при использовании setInterval вместо setTimeout: setInterval(f) запускает f несколько раз с 
нулевой задержкой, а затем с задержкой 4+ мс.
--------------
Итого

Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют выполнять func регулярно
или только один раз после задержки delay, заданной в мс.

Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, 
которое возвращают методы setInterval/setTimeout.

Вложенный вызов setTimeout является более гибкой альтернативой setInterval. 
Также он позволяет более точно задать интервал между выполнениями.
Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое, setTimeout(func) используется для вызовов, 
которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.
Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами setTimeout,
а также для setInterval, начиная с 5-го вызова.
Обратим внимание, что все методы планирования не гарантируют точную задержку.

Например, таймер в браузере может замедляться по многим причинам:

Перегружен процессор.
Вкладка браузера в фоновом режиме.
Работа ноутбука от аккумулятора.
Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 
300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС

_____________________________________________Декораторы и переадресация вызова, call/apply___________________________________
https://learn.javascript.ru/call-apply-decorators

-----------
func.call(context, arg1, arg2, ...) - сразу вызывает функцию; принимает безконечное число параметров списком.

Он запускает функцию func, используя первый аргумент как её контекст this, а последующие – как её аргументы.
Проще говоря, эти два вызова делают почти то же самое:
-----------
func.apply(context, args) - сразу вызывает функцию; принимает только два параметра; args - только в виде массива;

Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.
Единственная разница в синтаксисе между call и apply состоит в том, что call ожидает список аргументов, 
в то время как apply принимает псевдомассив.
-----------
Заимствование метода у массива.

function hash() {
  alert( [].join.call(arguments) ); // 1,2
}
hash(1, 2);
-------------
Перенаправление вызова

Передача всех аргументов вместе с контекстом другой функции называется «перенаправлением вызова» (call forwarding).
Простейший вид такого перенаправления:

let wrapper = function() {
  return func.apply(this, arguments);
};
При вызове wrapper из внешнего кода его не отличить от вызова исходной функции.
-----------------
Переадресация вызова
В основном переадресация вызова выполняется с помощью apply:

let wrapper = function(original, arguments) {
  return original.apply(this, arguments);
};
________________________________________Привязка контекста к функции bind_______________________________________

let bound = func.bind(context, [arg1], [arg2], ...); возвращает функцию не вызывая ее; привязывает this и аргументы; 

Аргументы это не обязательный параметр можно просто 
let bound = func.bind(context)
-------------------
Частичное применение

function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2); // привязываем только аргумент; контекст = null;

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10

Вызов mul.bind(null, 2) создаёт новую функцию double, которая передаёт вызов mul, фиксируя null как контекст, и 2 – как первый 
аргумент. Следующие аргументы передаются как есть.
Это называется частичное применение – мы создаём новую функцию, фиксируя некоторые из существующих параметров.
Обратите внимание, что в данном случае мы на самом деле не используем this. Но для bind это обязательный параметр, 
так что мы должны передать туда что-нибудь вроде null.
-------------------
Частичное применение без контекста
https://learn.javascript.ru/bind#chastichnoe-primenenie-bez-konteksta
-------------------
Итого
Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.

Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка. Например, для setTimeout.

Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».

Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз. 
Например, если у нас есть функция send(from, to) и from всё время будет одинаков для нашей задачи, 
то мы можем создать частично применённую функцию и дальше работать с ней.
------------------
______________________________________Повторяем стрелочные функции___________________________________________
https://learn.javascript.ru/arrow-functions

Итого
Стрелочные функции:

Не имеют this.
Не имеют arguments.
Не могут быть вызваны с new.
(У них также нет super, но мы про это не говорили. Про это будет в главе Наследование классов).
Всё это потому, что они предназначены для небольшого кода, который не имеет своего «контекста», выполняясь в текущем.
И они отлично справляются с этой задачей!


_____________________________________Флаги и дескрипторы свойств______________________________________
Флаги свойств
Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).

writable – если false, нельзя изменить так obj.key = value, *но свойство можно изменить через Object.defineProperty;

enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.

configurable – если false, нельзя удалить, (можно изменить value и writable только один раз на false
если на момент установки configurable = false одновременно было установленно writable = true, обратно вернуть нельзя) ,
нельзя изменить enymerable и configurable;

Мы ещё не встречали эти атрибуты, потому что обычно они скрыты. Когда мы создаём свойство «обычным способом», 
все они имеют значение true. Но мы можем изменить их в любое время.
-------------
let user = {
  name: "John"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name'); - информация о этих трех флагах свойства;
-------------
 Object.getOwnPropertyDescriptors(obj) - информация о флагах всех свойств обьекта;
-------------
Если свойство существует, defineProperty обновит его флаги. В противном случае метод создаёт новое свойство
с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение false.

Например, здесь создаётся свойство name, все флаги которого имеют значение false:

let user = {};

Object.defineProperty(user, "name", {
  value: "John"
});
-------------
Таким образом, мы можем определить множество свойств одной операцией.

Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
  // ...
});
-------------
Клонирование обьекта со всеми флагами и символьными свойствами.

Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).

Вместе с Object.defineProperties этот метод можно использовать для клонирования объекта вместе с его флагами:

let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
Обычно при клонировании объекта мы используем присваивание, чтобы скопировать его свойства:

for (let key in user) {
  clone[key] = user[key]
}
…Но это не копирует флаги. Так что если нам нужен клон «получше», предпочтительнее использовать Object.defineProperties.

Другое отличие в том, что for..in игнорирует символьные свойства, а Object.getOwnPropertyDescriptors возвращает дескрипторы 
всех свойств, включая свойства-символы.
-------------
Глобальное запечатывание объекта
Дескрипторы свойств работают на уровне конкретных свойств.

Но ещё есть методы, которые ограничивают доступ ко всему объекту:

Object.preventExtensions(obj)
Запрещает добавлять новые свойства в объект.

Object.seal(obj)
Запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.

Object.freeze(obj)
Запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.
А также есть методы для их проверки:

Object.isExtensible(obj)
Возвращает false, если добавление свойств запрещено, иначе true.

Object.isSealed(obj)
Возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств установлено configurable: false.

Object.isFrozen(obj)
Возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств
установлено configurable: false, writable: false.

На практике эти методы используются редко.


____________________________________Свойства - геттеры и сеттеры________________________________________

let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },

  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};

--------------
(get)

let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

alert(user.fullName); // John Smith

Снаружи свойство-аксессор выглядит как обычное свойство. В этом и заключается смысл свойств-аксессоров. 
Мы не вызываем user.fullName как функцию, а читаем как обычное свойство: геттер выполнит всю работу за кулисами.
--------------
(set)

let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

// set fullName запустится с данным значением
user.fullName = "Alice Cooper";

alert(user.name); // Alice
alert(user.surname); // Cooper
--------------
Дескрипторы свойств доступа
Дескрипторы свойств-аксессоров отличаются от «обычных» свойств-данных.

Свойства-аксессоры не имеют value и writable, но взамен предлагают функции get и set.

То есть, дескриптор аксессора может иметь:

get – функция без аргументов, которая сработает при чтении свойства,
set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
enumerable – то же самое, что и для свойств-данных,
configurable – то же самое, что и для свойств-данных.
Например, для создания аксессора fullName при помощи defineProperty мы можем передать дескриптор с использованием get и set:

let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
Ещё раз заметим, что свойство объекта может быть либо свойством-аксессором (с методами get/set), 
либо свойством-данным (со значением value).

При попытке указать и get, и value в одном дескрипторе будет ошибка:
--------------
Умные геттеры/сеттеры
Геттеры/сеттеры можно использовать как обёртки над «реальными» значениями свойств, чтобы получить больше контроля над операциями с ними.

Например, если мы хотим запретить устанавливать короткое имя для user, мы можем использовать сеттер name для проверки, а само значение хранить в отдельном свойстве _name:

let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое, должно быть более 4 символов");
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";
alert(user.name); // Pete

user.name = ""; // Имя слишком короткое...
Таким образом, само имя хранится в _name, доступ к которому производится через геттер и сеттер.

Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью user._name, 
но существует широко известное соглашение о том, что свойства, которые начинаются с символа "_", 
являются внутренними, и к ним не следует обращаться из-за пределов объекта.
--------------
Создание геттера в конструкторе

function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // возраст рассчитывается из текущей даты и дня рождения
  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}

let john = new User("John", new Date(1992, 6, 1));

alert( john.birthday ); // доступен как день рождения
alert( john.age );      // ...так и возраст
Теперь старый код тоже работает, и у нас есть отличное дополнительное свойство!


_________________________________________Прототипное наследование_________________________________
https://learn.javascript.ru/prototype-inheritance

[[Prototype]]
В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), 
которое либо равно null, либо ссылается на другой объект «прототип»;
------------
Есть только два ограничения:

Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
Значение __proto__ может быть объектом или null. Другие типы игнорируются.
Это вполне очевидно, но всё же: может быть только один [[Prototype]]. Объект не может наследоваться от двух других объектов.

Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

----------------------
Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода 
obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.

Пример такой фильтрации:

let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`Our: ${prop}`); // Our: jumps
  } else {
    alert(`Inherited: ${prop}`); // Inherited: eats
  }
}
--------------
Почти все остальные методы получения ключей/значений игнорируют унаследованные свойства
Почти все остальные методы, получающие ключи/значения, такие как Object.keys, Object.values и другие – игнорируют унаследованные свойства.
Они учитывают только свойства самого объекта, не его прототипа.

_____________________________________________F.prototype_________________________________________________
Прототип в конструкторах.

Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().
Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
------------

Обратите внимание, что F.prototype означает обычное свойство с именем "prototype" для F. Это ещё не «прототип объекта», 
а обычное свойство F с таким именем.

Приведём пример:

let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true

Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: 
"При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".
-------------
F.prototype используется только в момент вызова new F()
F.prototype используется только при вызове new F() и присваивается в качестве свойства [[Prototype]] нового объекта.
После этого F.prototype и новый объект ничего не связывает. Следует понимать это как «единоразовый подарок» объекту.

После создания F.prototype может измениться, и новые объекты, созданные с помощью new F(), будут иметь другой объект в 
качестве [[Prototype]], но уже существующие объекты сохранят старый.
-------------
function Rabbit() {}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // true

let rabbit = new Rabbit(); // наследует от {constructor: Rabbit}

alert(rabbit.constructor == Rabbit); // true (свойство получено из прототипа)
--------------
Мы можем использовать свойство constructor существующего объекта для создания нового.

Пример:

function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit("White Rabbit");

let rabbit2 = new rabbit.constructor("Black Rabbit");
--------------


_______________________________________________Встроенные прототипы______________________________________________________________
https://learn.javascript.ru/native-prototypes

Цепочки прототипов.------
--------------
let obj = {};
console.log(obj.__proto__ == Object.prototype && Object.prototype.__proto__ == null ); // true

--------------
let arr = [1, 2, 3];
arr.__proto__ == Array.prototype && Array.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null // true

--------------
function func(){};
console.log(func.__proto__ == Function.prototype && Function.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null );// true

--------------
let date = new Date();
  console.log(date.__proto__ == Date.prototype && Date.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null )// true

--------------
let num = 100;
  console.log(num.__proto__ == Number.prototype && Number.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null )// true

--------------
let str = "string";
  console.log(str.__proto__ == String.prototype && String.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null )

--------------
Примитивы

Самое сложное происходит со строками, числами и булевыми значениями.
Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием
встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.

Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, но спецификация описывает это именно таким образом.
Методы этих объектов также находятся в прототипах, доступных как String.prototype, Number.prototype и Boolean.prototype.

Значения null и undefined не имеют объектов-обёрток
Специальные значения null и undefined стоят особняком. У них нет объектов-обёрток, так что методы и свойства им недоступны. Также у них нет 
соответствующих прототипов.
-------------
Изменение встроенных прототипов

Function.prototype.defer = function(ms) {
  let f = this;
  return function(...args) {
    setTimeout(() => f.apply(this, args), ms);
  }
};

// check it
function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // выведет 3 через 1 секунду.
--------------
Заимствование у прототипов
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};

obj.join = Array.prototype.join;

alert( obj.join(',') ); // Hello,world!

__________________________________________Методы прототипов, объекты без свойства __proto_______________________________________________
https://learn.javascript.ru/prototype-methods

Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto,
и необязательными дескрипторами свойств descriptors.

let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: "I jump",
    writable: true,
    enumerable: true,
    conficurable: true
  }
});

console.log(rabbit.jumps) // "I jump"
------------
Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
------------
Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
------------
------------
Эти методы нужно использовать вместо __proto__.

Например:

let animal = {
  eats: true
};

// создаём новый объект с прототипом animal
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit

Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
У Object.create есть необязательный второй аргумент: дескрипторы свойств.
------------
Мы также можем использовать Object.create для «продвинутого» клонирования объекта, более мощного, чем копирование свойств в цикле for..in:
// клон obj c тем же прототипом (с поверхностным копированием свойств)

let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));

Такой вызов создаёт точную копию объекта obj, включая все свойства: перечисляемые и неперечисляемые, геттеры/сеттеры для свойств – и всё 
это с правильным свойством [[Prototype]].
------------
Не меняйте [[Prototype]] существующих объектов, если важна скорость
Технически мы можем установить/получить [[Prototype]] в любое время. Но обычно мы устанавливаем прототип только раз во время создания объекта, 
а после не меняем: rabbit наследует от animal, и это не изменится.

И JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью Object.setPrototypeOf или obj.__proto__= – очень медленная 
операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта. Так что лучше избегайте этого кроме тех случаев, когда вы знаете, 
что делаете, или же когда скорость JavaScript для вас не имеет никакого значения.
------------
"Простейший" объект
https://learn.javascript.ru/prototype-methods#very-plain

------------
Итого
Современные способы установки и прямого доступа к прототипу это:

Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto (может быть null), 
и необязательными дескрипторами свойств.
Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj (то же самое, что и геттер __proto__).
Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto (то же самое, что и сеттер __proto__).
Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте. Как минимум потому,
что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, 
они непредсказуемы.

Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.

Кроме этого, Object.create даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:

let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
Мы также ясно увидели, что __proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.

Мы можем создавать объекты без прототипов с помощью Object.create(null). Такие объекты можно использовать как «чистые словари», у них нет проблем
с использованием строки "__proto__" в качестве ключа.

Ещё методы:

Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.
Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.
Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.

Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и 
унаследованные, можно воспользоваться циклом for..in.
_______________________________________________Классы базовый синтаксис______________________________________________________________
https://learn.javascript.ru/class
Базовый синтаксис для классов выглядит так:

class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}

MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются
в MyClass.prototype.
---------------
Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".
---------------
Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
---------------
Class Expression (по аналогии с Function Expression):

let User = class {
  sayHi() {
    alert("Привет");
  }
};
Аналогично Named Function Expression, Class Expression может иметь имя.

Если у Class Expression есть имя, то оно видно только внутри класса:

// "Named Class Expression"
// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // имя MyClass видно только внутри класса
  }
};

new User().sayHi(); // работает, выводит определение MyClass

alert(MyClass); // ошибка, имя MyClass не видно за пределами класса
---------------
Мы даже можем динамически создавать классы «по запросу»:

function makeClass(phrase) {
  // объявляем класс и возвращаем его
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// Создаём новый класс
let User = makeClass("Привет");

new User().sayHi(); // Привет
---------------
Геттеры/сеттеры, другие сокращения
Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

Вот пример user.name, реализованного с использованием get/set:

class User {

  constructor(name) {
    // вызывает сеттер
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое.");
      return;
    }
    this._name = value;
  }

}

let user = new User("Иван");
alert(user.name); // Иван

user = new User(""); // Имя слишком короткое.
---------
При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:

Object.defineProperties(User.prototype, {
  name: {
    get() {
      return this._name
    },
    set(name) {
      // ...
    }
  }
});
Пример с вычисляемым свойством в скобках [...]:

class User {

  ['say' + 'Hi']() {
    alert("Привет");
  }

}

new User().sayHi();
---------------
Свойства классов
Старым браузерам может понадобиться полифил
Свойства классов добавлены в язык недавно.

В приведённом выше примере у класса User были только методы. Давайте добавим свойство:

class User {
  name = "Аноним";

  sayHi() {
    alert(`Привет, ${this.name}!`);
  }
}

new User().sayHi();
Свойство name не устанавливается в User.prototype. Вместо этого оно создаётся оператором new перед запуском конструктора, это именно свойство объекта.

__________________________________________________Наследование классов___________________________________________________________
Ниже Rabbit наследует от Animal:

class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} стоит.`);
  }
}

// Наследуем от Animal указывая "extends Animal"
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.hide(); // Белый кролик прячется!

Теперь код Rabbit стал короче, так как используется конструктор класса Animal по умолчанию и кролик 
может использовать метод run как и все животные.

Ключевое слово extends работает, используя прототипы. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. 
Так что если метод не найден в Rabbit.prototype, JavaScript берёт его из Animal.prototype.
---------------
После extends разрешены любые выражения
Синтаксис создания класса допускает указывать после extends не только класс, но любое выражение.

Пример вызова функции, которая генерирует родительский класс:

function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}

class User extends f("Привет") {}

new User().sayHi(); // Привет
Здесь class User наследует от результата вызова f("Привет").

Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от
многих условий и затем наследовать их.
---------------
Переопределение методов
Давайте пойдём дальше и переопределим метод. Сейчас Rabbit наследует от Animal метод stop, который устанавливает this.speed = 0.

Если мы определим свой метод stop в классе Rabbit, то он будет использоваться взамен родительского:

У классов есть ключевое слово "super" для таких случаев.

super.method(...) вызывает родительский метод.
super(...) вызывает родительский конструктор (работает только внутри нашего конструктора).
Пусть наш кролик автоматически прячется при остановке:

class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} стоит.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }

  stop() {
    super.stop(); // вызываем родительский метод stop
    this.hide(); // и затем hide
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop() в процессе выполнения.И родительский конструктор где задается name;
---------------
У стрелочных функций нет super
Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не имеют super.

При обращении к super стрелочной функции он берётся из внешней функции:

class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
  }
}
В примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:

// Unexpected super
setTimeout(function() { super.stop() }, 1000);
---------------
Переопределение конструктора
С конструкторами немного сложнее.

До сих пор у Rabbit не было своего конструктора.

Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:

class Rabbit extends Animal {
  // генерируется для классов-потомков, у которых нет своего конструктора
  constructor(...args) {
    super(...args);
  }
}
Как мы видим, он просто вызывает конструктор родительского класса. Так будет происходить, пока мы не создадим собственный конструктор.
---------------
class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// теперь работает
let rabbit = new Rabbit("Белый кролик", 10);
alert(rabbit.name); // Белый кролик
alert(rabbit.earLength); // 10
---------------
[[HomeObject]]
Для решения этой проблемы в JavaScript было добавлено специальное внутреннее свойство для функций: [[HomeObject]].

Когда функция объявлена как метод внутри класса или объекта, её свойство [[HomeObject]] становится равно этому объекту.

Затем super использует его, чтобы получить прототип родителя и его методы.

Давайте посмотрим, как это работает – опять же, используя простые объекты:

let animal = {
  name: "Животное",
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} ест.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "Кролик",
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: "Длинноух",
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// работает верно
longEar.eat();  // Длинноух ест.
Это работает как задумано благодаря [[HomeObject]]. Метод, такой как longEar.eat, знает свой [[HomeObject]] и получает
метод родителя из его прототипа. Вообще без использования this.
---------------
Методы, а не свойства-функции
Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как method(), а не "method: function()".

Для нас различий нет, но они есть для JavaScript.

В приведённом ниже примере используется синтаксис не метода, свойства-функции. Поэтому у него нет [[HomeObject]], и наследование не работает:

let animal = {
  eat: function() { // намеренно пишем так, а не eat() { ...
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // Ошибка вызова super (потому что нет [[HomeObject]])

_______________________________________________Статические свойства и методы______________________________________________________________
https://learn.javascript.ru/static-properties-methods

Итого
Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.

Например, метод для сравнения двух статей Article.compare(article1, article2) или фабричный метод Article.createTodays().

В объявлении класса они помечаются ключевым словом static.

Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.

Синтаксис:

class MyClass {
  static property = ...;

  static method() {
    ...
  }
}
Технически, статическое объявление – это то же самое, что и присвоение классу:

MyClass.property = ...
MyClass.method = ...

Статические свойства и методы наследуются.
Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.

_____________________________________________Приватные и защищённые методы и свойства________________________________________________________________
В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.

Внутренний и внешний интерфейсы
В объектно-ориентированном программировании свойства и методы разделены на 2 группы:

Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
Внешний интерфейс – методы и свойства, доступные снаружи класса.
---------------
Защищённые свойства обычно начинаются с префикса _.

Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.

Так что наше свойство будет называться _waterAmount:

class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }

}

// создаём новую кофеварку
let coffeeMachine = new CoffeeMachine(100);

// устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды
Теперь доступ под контролем, поэтому указать воду ниже нуля не удалось.
---------------
Свойство только для чтения «power»
Давайте сделаем свойство power доступным только для чтения. Иногда нужно, чтобы свойство устанавливалось только при создании объекта и после этого никогда не изменялось.

Это как раз требуется для кофеварки: мощность никогда не меняется.

Для этого нам нужно создать только геттер, но не сеттер:

class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

}

// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

alert(`Мощность: ${coffeeMachine.power}W`); // Мощность: 100W

coffeeMachine.power = 25; // Error (no setter)
---------------
Защищённые поля наследуются
Если мы унаследуем class MegaMachine extends CoffeeMachine, ничто не помешает нам обращаться к 
this._waterAmount или this._power из методов нового класса.

Таким образом защищённые методы, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.
---------------
Геттеры/сеттеры
Здесь мы использовали синтаксис геттеров/сеттеров.

Но в большинстве случаев использование функций get.../set... предпочтительнее:

class CoffeeMachine {
  _waterAmount = 0;

  setWaterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }

  getWaterAmount() {
    return this._waterAmount;
  }
}

new CoffeeMachine().setWaterAmount(100);
Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны).
Итак, на будущее, если нам надо что-то отрефакторить, функции – более безопасный выбор.

С другой стороны, синтаксис get/set короче, решать вам.
-------------------------
Приватное свойство «#waterLimit»
Новая возможность
Эта возможность была добавлена в язык недавно. В движках JavaScript пока не поддерживается или поддерживается частично, нужен полифил.
Есть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов.

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
--
class coffeMashin {
  #limitWater = 200;
  
  set limitWater(value){
    if(value < 0) throw new Error("Very small water count");
    if(value > this.#limitWater ) throw new Error('Very big water count');
    this.#limitWater = value;
  }
  
  get limitWater() {
      return this.#limitWater;
    }
}

let coff = new coffeMashin();
coff.limitWater = 55
console.log(coff.limitWater)
---------------
В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.

Но если мы унаследуем от CoffeeMachine, то мы не получим прямого доступа к #waterAmount. Мы будем вынуждены полагаться на геттер/сеттер waterAmount:

class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine
  }
}
Во многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем CoffeeMachine, у нас может быть вполне 
законная причина для доступа к внутренним методам и свойствам. 
Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.
---------------
Важно:
Приватные поля особенные.

Как мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]:

class User {
  ...
  sayHi() {
    let fieldName = "name";
    alert(`Hello, ${this[fieldName]}`);
  }
}
С приватными свойствами такое невозможно: this['#name'] не работает. Это ограничение синтаксиса сделано для обеспечения приватности.

_________________________________________________Расширение встроенных классов____________________________________________________________
От встроенных классов, таких как Array, Map и других, тоже можно наследовать.

// добавим один метод (можно более одного)
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // false
Обратите внимание на интересный момент: встроенные методы, такие как filter, map и другие возвращают новые объекты унаследованного класса PowerArray. Их внутренняя реализация такова, что для этого они используют свойство объекта constructor.

В примере выше,

arr.constructor === PowerArray
Поэтому при вызове метода arr.filter() он внутри создаёт массив результатов, именно используя arr.constructor, а не обычный массив. Это замечательно, поскольку можно продолжать использовать методы PowerArray далее на результатах.

Более того, мы можем настроить это поведение.

При помощи специального статического геттера Symbol.species можно вернуть конструктор, который JavaScript будет использовать в filter, map и других методах для создания новых объектов.

Если бы мы хотели, чтобы методы map, filter и т. д. возвращали обычные массивы, мы могли бы вернуть Array в Symbol.species, вот так:

class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  // встроенные методы массива будут использовать этот метод как конструктор
  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

// filter создаст новый массив, используя arr.constructor[Symbol.species] как конструктор
let filteredArr = arr.filter(item => item >= 10);

// filteredArr не является PowerArray, это Array
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function
Как вы видите, теперь .filter возвращает Array. Расширенная функциональность не будет передаваться далее.

Аналогично работают другие коллекции
Другие коллекции, такие как Map, Set, работают аналогично. Они также используют Symbol.species.
-------------
Отсутствие статического наследования встроенных классов
У встроенных объектов есть собственные статические методы, например Object.keys, Array.isArray и т. д.

Как мы уже знаем, встроенные классы расширяют друг друга.

Обычно, когда один класс наследует другой, то наследуются и статические методы. Это было подробно разъяснено в главе Статические свойства и методы.

Но встроенные классы – исключение. Они не наследуют статические методы друг друга.

Например, и Array, и Date наследуют от Object, так что в их экземплярах доступны методы из Object.prototype. 
Но Array.[[Prototype]] не ссылается на Object, поэтому нет методов Array.keys() или Date.keys().
_______________________________________________Проверка класса: "instanceof"_____________________________________________________________
Оператор instanceof позволяет проверить, к какому классу принадлежит объект, с учётом цепочки наследования.
Оператор вернёт true, если obj принадлежит классу Class или наследующему от него.

class Rabbit {}
let rabbit = new Rabbit();

// это объект класса Rabbit?
alert( rabbit instanceof Rabbit ); // true
Также это работает с функциями-конструкторами:

// вместо класса
function Rabbit() {}

alert( new Rabbit() instanceof Rabbit ); // true
…И для встроенных классов, таких как Array:

let arr = [1, 2, 3];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true
Пожалуйста, обратите внимание, что arr также принадлежит классу Object, потому что Array наследует от Object.
-------------
Обычно оператор instanceof просматривает для проверки цепочку прототипов. Но это поведение может быть изменено при помощи статического
метода Symbol.hasInstance.

Алгоритм работы obj instanceof Class работает примерно так:

Если имеется статический метод Symbol.hasInstance, тогда вызвать его: Class[Symbol.hasInstance](obj). Он должен вернуть либо true, 
либо false, и это конец. Это как раз и есть возможность ручной настройки instanceof.

Пример:

// проверка instanceof будет полагать,
// что всё со свойством canEat - животное Animal
class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}

let obj = { canEat: true };
alert(obj instanceof Animal); // true: вызван Animal[Symbol.hasInstance](obj)
Большая часть классов не имеет метода Symbol.hasInstance. В этом случае используется стандартная логика: проверяется, равен ли Class.prototype
одному из прототипов в прототипной цепочке obj.

Другими словами, сравнивается:

obj.__proto__ === Class.prototype?
obj.__proto__.__proto__ === Class.prototype?
obj.__proto__.__proto__.__proto__ === Class.prototype?
...
// если какой-то из ответов true - возвратить true
// если дошли до конца цепочки - false
В примере выше rabbit.__proto__ === Rabbit.prototype, так что результат будет получен немедленно.
В случае с наследованием, совпадение будет на втором шаге:
-------------
Кстати, есть метод objA.isPrototypeOf(objB), который возвращает true, если объект objA есть где-то в прототипной цепочке объекта objB.
Так что obj instanceof Class можно перефразировать как Class.prototype.isPrototypeOf(obj).
Забавно, но сам конструктор Class не участвует в процессе проверки! Важна только цепочка прототипов Class.prototype.
-------------
Object.prototype.toString возвращает тип

// скопируем метод toString в переменную для удобства
let objectToString = Object.prototype.toString;

// какой это тип?
let arr = [];

alert( objectToString.call(arr) ); // [object Array]
----
let s = Object.prototype.toString;

alert( s.call(123) ); // [object Number]
alert( s.call(null) ); // [object Null]
alert( s.call(alert) ); // [object Function]
-------------
Symbol.toStringTag
Поведение метода объектов toString можно настраивать, используя специальное свойство объекта Symbol.toStringTag.

Например:

let user = {
  [Symbol.toStringTag]: "User"
};

alert( {}.toString.call(user) ); // [object User]
Такое свойство есть у большей части объектов, специфичных для определённых окружений. Вот несколько примеров для браузера:
----
class PowerArray extends Number {
  static [Symbol.toStringTag] = "user";
}
console.log(Object.prototype.toString.call(PowerArray))//[object user]
----
// toStringTag для браузерного объекта и класса
alert( window[Symbol.toStringTag]); // window
alert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest

alert( {}.toString.call(window) ); // [object Window]
alert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]

-------------
____________________________________________________________________________________________________________
____________________________________________________________________________________________________________
____________________________________________________________________________________________________________
____________________________________________________________________________________________________________

-------------
-------------
