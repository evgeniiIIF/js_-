_____________________________________________________________Движки___________________________________________________________________________

У браузера есть собственный движок, который иногда называют «виртуальная машина JavaScript».

Разные движки имеют разные «кодовые имена». Например:

V8 – в Chrome и Opera.
SpiderMonkey – в Firefox.
…Ещё есть «Trident» и «Chakra» для разных версий IE, «ChakraCore» для Microsoft Edge, «Nitro» и «SquirrelFish» для Safari и т.д.
_____________________________________________________________Добавление скрипта___________________________________________________________________________

Вышеприведённый пример можно разделить на два скрипта:

<script src="file.js"></script>
<script>
  alert(1);
</script>
Итого
Для добавления кода JavaScript на страницу используется тег <script>
Атрибуты type и language необязательны.
Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>.
_____________________________________________________________Структура кода___________________________________________________________________________

alert("Теперь всё в порядке");

[1, 2].forEach(alert)
---------------------коментарии--------------------------
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
---------------------------------
/* Закомментировали код
alert('Привет');
*/
alert('Мир');
---------------------------------
Используйте горячие клавиши!
В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+/ для 
однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев
(выделите кусок кода и нажмите комбинацию клавиш).
В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.
_________________________________________________Строгий режим — "use strict"_____________________________________________________________________
"use strict";

// этот код работает в современном режиме
...
----------------
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке

"use strict";

// строгий режим не активирован
Над "use strict" могут быть записаны только комментарии.

-------------------
'use strict'; <Shift+Enter для перехода на новую строку>
//  ...ваш код...
<Enter для запуска>
В большинстве браузеров, включая Chrome и Firefox, это работает.

В старых браузерах консоль не учитывает такой use strict, там можно «оборачивать» код в функцию, вот так:

(function() {
  'use strict';

  // ...ваш код...
})()
_____________________________________________________________Переменные___________________________________________________________________________

Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!
-----------------
несколько переменных

let user = 'John';
let age = 25;
let message = 'Hello';
-------------------
Мы также можем изменить его столько раз, сколько захотим:

let message;

message = 'Hello!';

message = 'World!'; // значение изменено

alert(message);
-------------------
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!
------------------
Повторное объявление вызывает ошибку
Переменная может быть объявлена только один раз.

Повторное объявление той же переменной является ошибкой:

let message = "Это";

// повторение ключевого слова 'let' приводит к ошибке
let message = "Другое"; // SyntaxError: 'message' has already been declared
Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
-------------------
Имена переменных
В JavaScript есть два ограничения, касающиеся имён переменных:

Имя переменной должно содержать только буквы, цифры или символы $ и _.
Первый символ не должен быть цифрой.
Примеры допустимых имён:

let userName;
let test123;
Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое 
следующее слово начинается с заглавной буквы: myVeryLongName.

Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, 
как и буквы, без какого-либо особого значения.
Регистр имеет значение
Переменные с именами apple и AppLE – это две разные переменные.
--------------------
Зарезервированные имена
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

Например: let, class, return и function зарезервированы.

Приведённый ниже код даёт синтаксическую ошибку:

let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!
---------------------
Константы
Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

const myBirthday = '18.04.1982';
Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:

const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
Если программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через const.
--------------------
неизменяемые константы пишем в верхнем регистре
const COLOR_ORANGE = "#FF7F00";

изменяемые в нижнем
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
--------------------

_____________________________________________________________Типы данных___________________________________________________________________________

В JavaScript есть 8 основных типов.

number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
object для более сложных структур данных.
symbol для уникальных идентификаторов.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
_______________________________________Взаимодействие: alert, prompt, confirm__выпадаючие окна_______________________________________________________

Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

alert
показывает сообщение.
alert("Hello");
Hello
-------------
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null,
если была нажата кнопка «Отмена» или Esc с клавиатуры.Функция prompt принимает два аргумента:

result = prompt(title, [default]);
Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

title
Текст для отображения в окне.
default
Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.
Квадратные скобки в синтаксисе [...]
Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result. Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.

Например:

let age = prompt('Сколько тебе лет?', 100);

alert(`Тебе ${age} лет!`); // Тебе 100 лет!
Для IE: всегда устанавливайте значение по умолчанию
Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку "undefined" в поле для ввода.

Запустите код в Internet Explorer и посмотрите на результат:

let test = prompt("Test");
Чтобы prompt хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:

let test = prompt("Test", ''); // <-- для IE
------------------
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, 
если нажата кнопка «Отмена» или Esc с клавиатуры.
result = confirm(question);
Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

Результат – true, если нажата кнопка OK. В других случаях – false.

Например:

let isBoss = confirm("Ты здесь главный?");

alert( isBoss ); // true, если нажата OK
-----------------
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной 
частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия
с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

_____________________________________________________________Обьекты___________________________________________________________________________
let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};
_________________
если использовать число в качестве ключа, то оно превратится в строку "0":

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
_________________
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали
_________________

// получаем свойства объекта: получить значение свойства обьекта
alert( user.name ); // John
alert( user.age ); // 30
_________________
let key = prompt("Что вы хотите узнать о пользователе?", "name"); 
или let key = "name"

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name")
_________________

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
alert(user["likes birds"]); // true

Значение может быть любого типа. Давайте добавить свойство в обьект с логическим значением:
user.isAdmin = true;
user["likes birds"] = true;

удалить свойство обьекта 
delete user.age;

Проверить существует ли ключь в обьекте (свойство с ключем)
"age" in object
========или============
let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key

-----------------------
Цикл для обьектов «for…in»
Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
-----------------------
Проверка обьекта на пустоту
Просто в цикле перебираем свойства объекта и возвращаем false, как только встречаем свойство./
function isEmpty(obj) {
  for (let key in obj) {
    // если тело цикла начнет выполняться - значит в объекте есть свойства
    return false;
  }
  return true;
}
-----------------------
Упорядочевание свойств
свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
https://learn.javascript.ru/object#uporyadochenie-svoystv-obekta
-----------------------
Клонирование и объединение объектов, Object.assign
При копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект.
дублировать объект Создать независимую копию, клон?

Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех 
перечисленных объектов, начиная со второго, копируются в первый объект.
Возвращает объект dest.

et user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }
Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
___________________
Мы также можем использовать Object.assign для замены for..in на простое клонирование:

let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);
Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.
_____________
Глубокое клонирование, используя рекурсию.
Или, чтобы не изобретать велосипед, использовать готовую 
реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
-----------------------
Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который использовался для вызова метода.

Например:

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
-----------------------
Конструкторы, создание объектов через "new"
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // fals
_______________
ели есть return

function BigUser() {
  this.name = "Вася";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект

А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно)
function SmallUser() {
  this.name = "Вася";
  return; // <-- возвращает this
}
alert( new SmallUser().name );  // Вася
_______________
Создание методов в конструкторе
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
-----------------------
Символы
// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

Если же мы действительно хотим вывести символ с помощью alert, 
то необходимо явно преобразовать его с помощью метода .toString(), вот так:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает
Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

let id = Symbol("id");
alert(id.description); // id
_______________________
Мы хотим добавить к ним идентификаторы.
Используем для этого символьный ключ:

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
_____________________
Символы в литеральном объекте
Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
___________
Символы игнорируются циклом for…in
А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
__________
Одинаковые символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
_____________
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
______________
Впрочем, для любых символов доступно свойство description.

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

alert( localSymbol.description ); // name
-----------------------
Преобразование объектов в примитивы
https://learn.javascript.ru/object-toprimitive

записать метод в обьект.
obj[Symbol.toPrimitive] = function(hint) {
  // должен вернуть примитивное значение
  // hint равно чему-то одному из: "string", "number" или "default"
};
______________
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
_____________
Методы toString и valueOf берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало, а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов.

Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти эти методы и вызвать их следующим образом:

toString -> valueOf для хинта со значением «string».
valueOf -> toString – в ином случае.
Для примера, используем их в реализации всё того же объекта user. Воспроизведём его поведение комбинацией методов toString и valueOf:

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
___________
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
_____________________________________________________________Числа___________________________________________________________________________
Чтобы писать числа с большим количеством нулей:

Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. Например: 123e-6 это 0.000123 (123 миллионных).
-----------------------
Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. 
Естественно, есть короткий стиль записи: 0x, после которого указывается число.

alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию parseInt
-----------------------
Число в строку
Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
-------
Две точки для вызова метода
Внимание! Две точки в 123456..toString(36) это не опечатка. 
Если нам надо вызвать метод непосредственно на числе, как toString в примере выше,
то нам надо поставить две точки .. после числа.
-----------------------
Округление

Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
-----------------------
Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:

let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
Обратите внимание, что результатом toFixed является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(5).
-----------------------
isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN уникально тем,
что оно не является равным ни чему другому, даже самому себе:

alert( NaN === NaN ); // false
-----------------------
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

alert( isFinite("") ); // true
alert( isFinite(null) ); // true
alert( isFinite("15") ); // true

alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
Иногда isFinite используется для проверки, содержится ли в строке число
-----------------------
Сравнение Object.is
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. 
Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, 
он использует Object.is (Определение SameValue).
-----------------------
Из строки с буквами в число 
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
------------
Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, 
таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
-----------------------
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math
В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Несколько примеров:

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.

alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
Math.pow(n, power)
Возвращает число n, возведённое в степень power

alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024
В объекте Math есть множество функций и констант, включая тригонометрические функции, подробнее можно ознакомиться в документации по объекту Math.
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------
-----------------------









_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________
_____________________________________________________________Структура кода___________________________________________________________________________


